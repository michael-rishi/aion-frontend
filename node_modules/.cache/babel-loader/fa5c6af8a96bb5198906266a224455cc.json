{"ast":null,"code":"/*\n * Copyright (c) 2017-2018 Aion foundation.\n *\n *     This file is part of the aion network project.\n *\n *     The aion network project is free software: you can redistribute it \n *     and/or modify it under the terms of the GNU General Public License \n *     as published by the Free Software Foundation, either version 3 of \n *     the License, or any later version.\n *\n *     The aion network project is distributed in the hope that it will \n *     be useful, but WITHOUT ANY WARRANTY; without even the implied \n *     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n *     See the GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with the aion network project source files.  \n *     If not, see <https://www.gnu.org/licenses/>.\n *\n * Contributors:\n *     Aion foundation.\n *     Fabian Vogelsteller <fabian@frozeman.de>\n */\n\"use strict\";\n\nvar _ = require(\"underscore\");\n\nvar core = require('aion-web3-core');\n\nvar Method = require('aion-web3-core-method');\n\nvar Promise = require('any-promise');\n\nvar uuid = require('uuid');\n\nvar utils = require('aion-web3-utils');\n\nvar isHex = utils.isHex;\nvar isHexStrict = utils.isHexStrict;\n\nvar formatters = require('aion-web3-core-helpers').formatters;\n\nvar errors = require('aion-web3-core-helpers').errors;\n\nvar aionLib = require('aion-lib');\n\nvar blake2b256 = aionLib.crypto.blake2b256;\nvar nacl = aionLib.crypto.nacl;\nvar scryptsy = aionLib.crypto.scrypt;\nvar cryp = aionLib.crypto.node;\nvar Buffer = aionLib.formats.Buffer;\nvar toBuffer = aionLib.formats.toBuffer;\nvar bufferToZeroXHex = aionLib.formats.bufferToZeroXHex;\nvar removeLeadingZeroX = aionLib.formats.removeLeadingZeroX;\n\nvar rlp = require('aion-rlp');\n\nvar AionLong = rlp.AionLong;\n\nvar BN = require('bn.js');\n\nvar aionPubSigLen = aionLib.accounts.aionPubSigLen;\n\nvar isNot = function isNot(value) {\n  return _.isUndefined(value) || _.isNull(value);\n};\n\nvar toAionLong = function toAionLong(val) {\n  var num;\n\n  if (val === undefined || val === null || val === '' || val === '0x') {\n    return null;\n  }\n\n  if (typeof val === 'string') {\n    if (val.indexOf('0x') === 0 || val.indexOf('0') === 0 || isHex(val) === true || isHexStrict(val) === true) {\n      num = new BN(removeLeadingZeroX(val), 16);\n    } else {\n      num = new BN(val, 10);\n    }\n  }\n\n  if (typeof val === 'number') {\n    num = new BN(val);\n  }\n\n  return new AionLong(num);\n};\n\nvar Accounts = function Accounts() {\n  var _this = this; // sets _requestmanager\n\n\n  core.packageInit(this, arguments); // remove unecessary core functions\n\n  delete this.BatchRequest;\n  delete this.extend;\n  var _ethereumCall = [new Method({\n    name: 'getId',\n    call: 'net_version',\n    params: 0,\n    outputFormatter: utils.hexToNumber\n  }), new Method({\n    name: 'getGasPrice',\n    call: 'eth_gasPrice',\n    params: 0\n  }), new Method({\n    name: 'getTransactionCount',\n    call: 'eth_getTransactionCount',\n    params: 2,\n    inputFormatter: [function (address) {\n      if (utils.isAddress(address)) {\n        return address;\n      } else {\n        throw errors.InvalidParamForMethod('transactionCount', 'Address', address);\n      }\n    }, function () {\n      return 'latest';\n    }]\n  })]; // attach methods to this._ethereumCall\n\n  this._ethereumCall = {};\n\n  _.each(_ethereumCall, function (method) {\n    method.attachToObject(_this._ethereumCall);\n    method.setRequestManager(_this._requestManager);\n  });\n\n  this.wallet = new Wallet(this);\n};\n\nAccounts.prototype._addAccountFunctions = function (account) {\n  var _this = this; // add sign functions\n\n\n  account.signTransaction = function signTransaction(tx, callback) {\n    return _this.signTransaction(tx, account._privateKey, callback);\n  };\n\n  account.sign = function sign(data) {\n    return _this.sign(data, account._privateKey);\n  };\n\n  account.encrypt = function encrypt(password, options) {\n    return _this.encrypt(account._privateKey, password, options);\n  };\n\n  return account;\n}; // replaces ethlib/lib/account.js#fromPrivate\n\n\nvar createAionAccount = function createAionAccount(opts) {\n  var account = aionLib.accounts.createKeyPair({\n    privateKey: opts.privateKey,\n    entropy: opts.entropy\n  });\n  account.address = aionLib.accounts.createA0Address(account.publicKey);\n  return account;\n};\n\nAccounts.prototype.create = function create(entropy) {\n  return this._addAccountFunctions(createAionAccount({\n    entropy: entropy\n  }));\n};\n\nAccounts.prototype.privateKeyToAccount = function privateKeyToAccount(privateKey) {\n  return this._addAccountFunctions(createAionAccount({\n    privateKey: privateKey\n  }));\n};\n\nAccounts.prototype.signTransaction = function signTransaction(tx, privateKey, callback) {\n  var _this = this,\n      error = false,\n      result;\n\n  var account = this.privateKeyToAccount(privateKey);\n\n  callback = callback || function () {};\n\n  if (!tx) {\n    error = errors.InvalidObject('transaction');\n    callback(error);\n    return Promise.reject(error);\n  }\n\n  function signed(tx) {\n    if (!tx.gas && !tx.gasLimit) {\n      error = errors.MissingParam('gas');\n    }\n\n    if (tx.nonce < 0 || tx.gas < 0 || tx.gasPrice < 0 || tx.type < 0 || tx.timestamp < 0) {\n      error = errors.LessThanZeroError('Gas, gasPrice, nonce, type, or timestamp');\n    }\n\n    if (error) {\n      callback(error);\n      return Promise.reject(error);\n    }\n\n    try {\n      tx = formatters.inputCallFormatter(tx);\n      var transaction = tx;\n      transaction.to = tx.to;\n      transaction.data = tx.data;\n      transaction.value = tx.value;\n      transaction.timestamp = tx.timestamp || Math.floor(Date.now() * 1000);\n      transaction.type = tx.type || 1;\n      var rlpEncoded = rlp.encode([transaction.nonce, transaction.to, transaction.value, transaction.data, transaction.timestamp, toAionLong(transaction.gas), toAionLong(transaction.gasPrice), toAionLong(transaction.type)]); // hash encoded message\n\n      var hash = blake2b256(rlpEncoded); // sign with nacl\n\n      var signature = toBuffer(nacl.sign.detached(hash, account._privateKey)); // verify nacl signature\n\n      if (nacl.sign.detached.verify(hash, signature, account.publicKey) === false) {\n        throw errors.InvalidSignature(true);\n      } // aion-specific signature scheme\n\n\n      var aionPubSig = Buffer.concat([account.publicKey, signature], aionPubSigLen); // add the aion pub-sig\n\n      var rawTx = rlp.decode(rlpEncoded).concat(aionPubSig); // re-encode with signature included\n\n      var rawTransaction = rlp.encode(rawTx);\n      result = {\n        messageHash: bufferToZeroXHex(hash),\n        signature: bufferToZeroXHex(aionPubSig),\n        rawTransaction: bufferToZeroXHex(rawTransaction)\n      };\n    } catch (e) {\n      callback(e);\n      return Promise.reject(e);\n    }\n\n    callback(null, result);\n    return result;\n  } // Resolve immediately if nonce, type and price are provided\n\n\n  if (tx.nonce !== undefined && tx.type !== undefined && tx.gasPrice !== undefined) {\n    return Promise.resolve(signed(tx));\n  } // Otherwise, get the missing info from the Ethereum Node\n\n\n  return Promise.all([isNot(tx.gasPrice) ? _this._ethereumCall.getGasPrice() : tx.gasPrice, isNot(tx.nonce) ? _this._ethereumCall.getTransactionCount(_this.privateKeyToAccount(privateKey).address) : tx.nonce]).then(function (args) {\n    if (isNot(args[0]) || isNot(args[1])) {\n      throw errors.FailureToFetch('\"type\", \"gasPrice\", or \"nonce\"', JSON.stringify(args));\n    }\n\n    return signed(_.extend(tx, {\n      gasPrice: args[0],\n      nonce: args[1]\n    }));\n  });\n};\n/* jshint ignore:start */\n\n\nAccounts.prototype.recoverTransaction = function recoverTransaction(rawTx) {\n  return this.recover(null, rlp.decode(rawTx).pop());\n};\n/* jshint ignore:end */\n\n\nAccounts.prototype.hashMessage = function hashMessage(data) {\n  var message = utils.isHexStrict(data) ? utils.hexToBytes(data) : data;\n  var messageBuffer = Buffer.from(message);\n  var preamble = \"\\x15Aion Signed Message:\\n\" + message.length;\n  var preambleBuffer = Buffer.from(preamble);\n  var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);\n  return utils.blake2b256(ethMessage);\n};\n\nAccounts.prototype.sign = function sign(data, privateKey) {\n  var account = this.privateKeyToAccount(privateKey);\n  var publicKey = account.publicKey;\n  var hash = this.hashMessage(data);\n  var signature = toBuffer(nacl.sign.detached(toBuffer(hash), toBuffer(privateKey))); // address + message signature\n\n  var aionPubSig = Buffer.concat([toBuffer(publicKey), toBuffer(signature)], aionPubSigLen);\n  return {\n    message: data,\n    messageHash: hash,\n    signature: bufferToZeroXHex(aionPubSig)\n  };\n};\n\nAccounts.prototype.recover = function recover(message, signature) {\n  var sig = signature || message && message.signature;\n  var publicKey = toBuffer(sig).slice(0, nacl.sign.publicKeyLength);\n  return aionLib.accounts.createA0Address(publicKey);\n}; // Taken from https://github.com/ethereumjs/ethereumjs-wallet\n\n\nAccounts.prototype.decrypt = function (v3Keystore, password, nonStrict) {\n  /* jshint maxcomplexity: 10 */\n  if (!_.isString(password)) {\n    throw errors.InvalidParam('password');\n  }\n\n  var json = _.isObject(v3Keystore) ? v3Keystore : JSON.parse(nonStrict ? v3Keystore.toLowerCase() : v3Keystore);\n\n  if (json.version !== 3) {\n    throw errors.InvalidObjVersion('v3', 'Wallet');\n  }\n\n  var derivedKey;\n  var kdfparams;\n\n  if (json.crypto.kdf === 'scrypt') {\n    kdfparams = json.crypto.kdfparams; // FIXME: support progress reporting callback\n\n    derivedKey = scryptsy(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else if (json.crypto.kdf === 'pbkdf2') {\n    kdfparams = json.crypto.kdfparams;\n\n    if (kdfparams.prf !== 'hmac-sha256') {\n      throw errors.InvalidParamForMethod('PBKDF2');\n    }\n\n    derivedKey = cryp.pbkdf2Sync(new Buffer(password), new Buffer(kdfparams.salt, 'hex'), kdfparams.c, kdfparams.dklen, 'sha256');\n  } else {\n    throw errors.UnsupportedParam('key derivation scheme');\n  }\n\n  var ciphertext = new Buffer(json.crypto.ciphertext, 'hex');\n  var mac = utils.blake2b256(Buffer.concat([derivedKey.slice(16, 32), ciphertext])).replace('0x', '');\n\n  if (mac !== json.crypto.mac) {\n    throw errors.FailedKeyDerivation();\n  }\n\n  var decipher = cryp.createDecipheriv(json.crypto.cipher, derivedKey.slice(0, 16), new Buffer(json.crypto.cipherparams.iv, 'hex'));\n  var seed = '0x' + Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString('hex');\n  return this.privateKeyToAccount(seed);\n};\n\nAccounts.prototype.encrypt = function (privateKey, password, options) {\n  /* jshint maxcomplexity: 20 */\n  var account = this.privateKeyToAccount(privateKey);\n  options = options || {};\n  var salt = options.salt || cryp.randomBytes(32);\n  var iv = options.iv || cryp.randomBytes(16);\n  var derivedKey;\n  var kdf = options.kdf || 'scrypt';\n  var kdfparams = {\n    dklen: options.dklen || 32,\n    salt: salt.toString('hex')\n  };\n\n  if (kdf === 'pbkdf2') {\n    kdfparams.c = options.c || 262144;\n    kdfparams.prf = 'hmac-sha256';\n    derivedKey = cryp.pbkdf2Sync(new Buffer(password), salt, kdfparams.c, kdfparams.dklen, 'sha256');\n  } else if (kdf === 'scrypt') {\n    // FIXME: support progress reporting callback\n    kdfparams.n = options.n || 8192; // 2048 4096 8192 16384\n\n    kdfparams.r = options.r || 8;\n    kdfparams.p = options.p || 1;\n    derivedKey = scryptsy(new Buffer(password), salt, kdfparams.n, kdfparams.r, kdfparams.p, kdfparams.dklen);\n  } else {\n    throw errors.UnsupportedParam('kdf');\n  }\n\n  var cipher = cryp.createCipheriv(options.cipher || 'aes-128-ctr', derivedKey.slice(0, 16), iv);\n\n  if (!cipher) {\n    throw errors.UnsupportedParam('cipher');\n  }\n\n  var ciphertext = Buffer.concat([cipher.update(account._privateKey), cipher.final()]);\n  var mac = utils.blake2b256(Buffer.concat([derivedKey.slice(16, 32), new Buffer(ciphertext, 'hex')])).replace('0x', '');\n  return {\n    version: 3,\n    id: uuid.v4({\n      random: options.uuid || cryp.randomBytes(16)\n    }),\n    address: account.address.toLowerCase().replace('0x', ''),\n    crypto: {\n      ciphertext: ciphertext.toString('hex'),\n      cipherparams: {\n        iv: iv.toString('hex')\n      },\n      cipher: options.cipher || 'aes-128-ctr',\n      kdf: kdf,\n      kdfparams: kdfparams,\n      mac: mac.toString('hex')\n    }\n  };\n}; // Note: this is trying to follow closely the specs on\n// http://web3js.readthedocs.io/en/1.0/web3-eth-accounts.html\n\n\nfunction Wallet(accounts) {\n  this._accounts = accounts;\n  this.length = 0;\n  this.defaultKeyName = \"web3js_wallet\";\n}\n\nWallet.prototype._findSafeIndex = function (pointer) {\n  pointer = pointer || 0;\n\n  if (_.has(this, pointer)) {\n    return this._findSafeIndex(pointer + 1);\n  } else {\n    return pointer;\n  }\n};\n\nWallet.prototype._currentIndexes = function () {\n  var keys = Object.keys(this);\n  var indexes = keys.map(function (key) {\n    return parseInt(key);\n  }).filter(function (n) {\n    return n < 9e20;\n  });\n  return indexes;\n};\n\nWallet.prototype.create = function (numberOfAccounts, entropy) {\n  for (var i = 0; i < numberOfAccounts; ++i) {\n    this.add(this._accounts.create(entropy).privateKey);\n  }\n\n  return this;\n};\n\nWallet.prototype.add = function (account) {\n  if (_.isString(account)) {\n    account = this._accounts.privateKeyToAccount(account);\n  }\n\n  if (!this[account.address]) {\n    account = this._accounts.privateKeyToAccount(account.privateKey);\n    account.index = this._findSafeIndex();\n    this[account.index] = account;\n    this[account.address] = account;\n    this[account.address.toLowerCase()] = account;\n    this.length++;\n    return account;\n  } else {\n    return this[account.address];\n  }\n};\n\nWallet.prototype.remove = function (addressOrIndex) {\n  var account = this[addressOrIndex];\n  var address;\n  var addressLower;\n  var index;\n\n  if (account && account.address) {\n    address = account.address;\n    addressLower = address.toLowerCase();\n    index = account.index;\n\n    if (this[address] !== undefined) {\n      delete this[address];\n    }\n\n    if (this[addressLower] !== undefined) {\n      delete this[addressLower];\n    }\n\n    if (index !== undefined && this[index] !== undefined) {\n      delete this[index];\n    }\n\n    this.length--;\n    return true;\n  } else {\n    return false;\n  }\n};\n\nWallet.prototype.clear = function () {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  indexes.forEach(function (index) {\n    _this.remove(index);\n  });\n  return this;\n};\n\nWallet.prototype.encrypt = function (password, options) {\n  var _this = this;\n\n  var indexes = this._currentIndexes();\n\n  var accounts = indexes.map(function (index) {\n    return _this[index].encrypt(password, options);\n  });\n  return accounts;\n};\n\nWallet.prototype.decrypt = function (encryptedWallet, password) {\n  var _this = this;\n\n  encryptedWallet.forEach(function (keystore) {\n    var account = _this._accounts.decrypt(keystore, password);\n\n    if (account) {\n      _this.add(account);\n    } else {\n      throw errors.FailedAccountDecryption();\n    }\n  });\n  return this;\n};\n\nWallet.prototype.save = function (password, keyName) {\n  localStorage.setItem(keyName || this.defaultKeyName, JSON.stringify(this.encrypt(password)));\n  return true;\n};\n\nWallet.prototype.load = function (password, keyName) {\n  var keystore = localStorage.getItem(keyName || this.defaultKeyName);\n\n  if (keystore) {\n    try {\n      keystore = JSON.parse(keystore);\n    } catch (e) {}\n  }\n\n  return this.decrypt(keystore || [], password);\n};\n\nif (typeof localStorage === 'undefined') {\n  delete Wallet.prototype.save;\n  delete Wallet.prototype.load;\n}\n\nmodule.exports = Accounts;","map":null,"metadata":{},"sourceType":"script"}