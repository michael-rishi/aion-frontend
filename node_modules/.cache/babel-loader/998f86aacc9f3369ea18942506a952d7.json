{"ast":null,"code":"/**\n * ABI encoding and decoding\n * @module abi\n */\nvar padStart = require('lodash.padstart');\n\nvar padEnd = require('lodash.padend');\n\nvar _require = require('underscore'),\n    isString = _require.isString,\n    isObject = _require.isObject,\n    isArray = _require.isArray,\n    isNumber = _require.isNumber;\n\nvar BN = require('bn.js');\n\nvar _require2 = require('./formats'),\n    copyString = _require2.copyString,\n    prependZeroX = _require2.prependZeroX,\n    toBuffer = _require2.toBuffer,\n    removeLeadingZeroX = _require2.removeLeadingZeroX,\n    bufferToHex = _require2.bufferToHex;\n\nvar _require3 = require('./crypto'),\n    keccak256 = _require3.keccak256;\n\nvar solidity = require('./solidity');\n\nvar values = require('./values');\n\nvar _require4 = require('./accounts'),\n    createChecksumAddress = _require4.createChecksumAddress;\n/**\n * Shared between function and event signatures. Creates a name/type combination\n * and hashes it to get the hex signature.\n * @param {string} val\n * @return {string} hash\n */\n\n\nfunction fnHashBuffer(val) {\n  var op;\n\n  if (isString(val) === true) {\n    op = copyString(val);\n  }\n\n  if (isObject(val) === true) {\n    op = copyString(val.name);\n\n    if (isArray(val.inputs) === true) {\n      op += '(' + val.inputs.map(function (item) {\n        return item.type;\n      }).join(',') + ')';\n    }\n  }\n\n  return keccak256(op).slice(0, values.solidity.types.function.byteLength);\n}\n/**\n * Pad left or right depending on direction\n * @param {string} direction left or right\n * @param {number} length\n * @param {string} val\n * @return {string}\n */\n\n\nvar abiPad = function abiPad(direction, length, val) {\n  return (direction === 'left' ? padStart : padEnd)(val, length, '0');\n};\n/**\n * Encode padded ABI string value\n * @param {string} val\n * @return {string} hex\n */\n\n\nfunction encodeAbiString(val) {\n  var buf = toBuffer(val);\n  var bufHex = buf.toString('hex');\n  var valOp = abiPad(values.solidity.types.string.pad, values.solidity.types.string.stringLength, bufHex);\n  return valOp;\n}\n/**\n * Encode padded boolean to ABI format\n * @param {boolean} val\n * @return {string}\n */\n\n\nfunction encodeAbiBoolean(val) {\n  return copyString(val === true ? values.solidity.types.bool.one : values.solidity.types.bool.zero);\n}\n/**\n * A padded ABI formatted number\n * @param {number} val\n * @return {string}\n */\n\n\nfunction encodeAbiNumber(val) {\n  return abiPad(values.solidity.types.uint.pad, values.solidity.types.uint.stringLength, toBuffer(val).toString('hex'));\n}\n/**\n * ABI encoded Aion address\n * @param {string} val\n * @return {string}\n */\n\n\nfunction encodeAbiAddress(val) {\n  return removeLeadingZeroX(val).toLowerCase();\n} // replaces the need for switch case\n\n\nvar abiTypeEncoders = {\n  string: encodeAbiString,\n  bytes: encodeAbiString,\n  bool: encodeAbiBoolean,\n  uint: encodeAbiNumber,\n  int: encodeAbiNumber,\n  fixed: encodeAbiNumber,\n  ufixed: encodeAbiNumber,\n  address: encodeAbiAddress\n  /**\n   * Encode event to its ABI signature\n   * @method encodeEventSignature\n   * @param {string|object} val\n   * @return {string}\n   */\n\n};\n\nfunction encodeEventSignature(val) {\n  return prependZeroX(fnHashBuffer(val).toString('hex'));\n}\n/**\n * Encode function to its ABI signature\n * @method encodeFunctionSignature\n * @param {string|object} val\n * @return {string}\n */\n\n\nfunction encodeFunctionSignature(val) {\n  return prependZeroX(fnHashBuffer(val).slice(0, values.solidity.types.function.byteLengthEncoded).toString('hex'));\n}\n/**\n * Array reducer summing up all the items\n * @param {number} op accumulator\n * @param {number} item\n * @return {number}\n */\n\n\nvar sumLengthReduction = function sumLengthReduction(op, item) {\n  return op = op + item.length;\n};\n/**\n * Input an array of strings and calculate the length in bytes\n * @param {array} val\n * @return {number}\n */\n\n\nvar stringArrayByteLength = function stringArrayByteLength(val) {\n  return val.reduce(sumLengthReduction, 0) / 2;\n};\n/**\n * Converts from arrays of types and params into a data structure\n *\n * It's used by other functions in this module to build ABI encoding and\n * to give better information if the developer is curious to know\n * each line of bytes.\n *\n * @param {array} options.types\n * @param {array} options.params\n * @return {object}\n */\n\n\nfunction encodeParametersIntermediate(_ref) {\n  var types = _ref.types,\n      params = _ref.params;\n  var parsedTypes = types.map(solidity.parseType);\n  var useTopLevelOffsets = parsedTypes.some(function (item) {\n    return item.hasDynamicDimensions === true;\n  });\n  var op = [];\n  var rows = [];\n  parsedTypes.forEach(function (parsedType, paramIndex) {\n    var param = params[paramIndex];\n    var baseType = parsedType.baseType,\n        dimensions = parsedType.dimensions,\n        hasDimensions = parsedType.hasDimensions,\n        hasDynamicDimensions = parsedType.hasDynamicDimensions;\n    var valueEncoder = abiTypeEncoders[baseType];\n    var paramOp = [];\n    var paramLen = 0;\n\n    function addParamItem(item) {\n      paramOp.push(valueEncoder(item));\n    }\n\n    if (isArray(param) === false) {\n      paramLen = 1;\n      addParamItem(param);\n    }\n\n    if (isArray(param) === true) {\n      paramLen = param.length;\n\n      if (hasDynamicDimensions === true) {\n        paramOp.push(encodeAbiNumber(paramLen));\n      }\n\n      param.forEach(addParamItem);\n    }\n\n    var rowByteLen = stringArrayByteLength(paramOp);\n    rows.push({\n      hasDimensions: hasDimensions,\n      dimensions: dimensions,\n      rowByteLen: rowByteLen,\n      paramLen: paramLen,\n      paramOp: paramOp\n    });\n  });\n  var offset = 0;\n  /*if (useTopLevelOffsets === true) {\n    // first item is this many bytes down\n    offset += rows.length * 16\n    op.push(encodeAbiNumber(offset))\n     rows.forEach((item, index) => {\n      if (index === rows.length - 1) {\n        return\n      }\n      offset += item.rowByteLen\n      op.push(encodeAbiNumber(offset))\n    })\n  }*/\n\n  rows.forEach(function (item) {\n    op = op.concat(item.paramOp);\n  });\n  return {\n    parsedTypes: parsedTypes,\n    rows: rows,\n    lines: op\n  };\n}\n/**\n * Encode a list of parameters to ABI signature\n * @method encodeParameters\n * @param {array} types\n * @param {array} params\n * @return {string}\n */\n\n\nfunction encodeParameters(types, params) {\n  var op = encodeParametersIntermediate({\n    types: types,\n    params: params\n  });\n  op = op.lines;\n  op = op.join('');\n  op = prependZeroX(op);\n  return op;\n}\n/**\n * Encode parameter to ABI signature\n * @method encodeParameter\n * @param {string} type\n * @param {string|array|object} param\n * @return {string}\n */\n\n\nfunction encodeParameter(type, param) {\n  return encodeParameters([type], [param]);\n}\n/**\n * Encode function call to ABI signature\n * @method encodeFunctionCall\n * @param {object} jsonInterface\n * @param {array} params\n * @return {string}\n */\n\n\nfunction encodeFunctionCall(jsonInterface, params) {\n  var functionName = jsonInterface.name;\n  var functionHash = encodeFunctionSignature(functionName);\n  var types = jsonInterface.inputs.map(function (item) {\n    return item.type;\n  });\n  var typesParams = removeLeadingZeroX(encodeParameters(types, params));\n  return functionHash + typesParams;\n}\n\nfunction decodeAbiString(val) {\n  return toBuffer(val).toString('utf8');\n}\n\nfunction decodeAbiBytes(val) {\n  return toBuffer(val);\n}\n\nfunction decodeAbiBoolean(val) {\n  return val.pop() === 1 ? true : false;\n}\n\nfunction decodeAbiNumber(val) {\n  return new BN(bufferToHex(val), 'hex').toNumber();\n}\n\nfunction decodeAbiAddress(val) {\n  return createChecksumAddress(toBuffer(val).toString('hex'));\n}\n\nvar abiTypeDecodes = {\n  string: decodeAbiString,\n  bytes: decodeAbiBytes,\n  bool: decodeAbiBoolean,\n  uint: decodeAbiNumber,\n  int: decodeAbiNumber,\n  fixed: decodeAbiNumber,\n  ufixed: decodeAbiNumber,\n  address: decodeAbiAddress\n  /**\n   * Decode the parameters hex into an array of decoded values\n   * @method decodeParameters\n   * @param {array} types\n   * @param {string} val\n   * @return {array}\n   */\n\n};\n\nfunction decodeParameters(types, val) {\n  var typeList = [];\n\n  if (isArray(types) === true && isString(types[0]) === true) {\n    // array of string types\n    typeList = types;\n  }\n\n  if (isArray(types) === true && isString(types[0].type) === true) {\n    // json interface\n    typeList = types.map(function (item) {\n      return item.type;\n    });\n  }\n\n  if (isObject(types) === true && types.type !== undefined) {\n    // one from decode paramter\n    typeList = [types.type];\n  }\n\n  var parsedTypes = typeList.map(solidity.parseType);\n  var useTopLevelOffsets = parsedTypes.length > 1 && parsedTypes.some(function (item) {\n    return item.hasDynamicDimensions === true;\n  });\n  var bytes = toBuffer(val);\n  var op = [];\n  var cursor = 0;\n  var previousByteLength = 16;\n  var outerOffsets = [];\n\n  function readBytes(length) {\n    var op = bytes.slice(cursor, cursor + length);\n    cursor += length;\n    return op;\n  }\n\n  if (useTopLevelOffsets === true) {\n    parsedTypes.forEach(function () {\n      outerOffsets.push(decodeAbiNumber(readBytes(16)));\n    });\n    console.log('outerOffsets', outerOffsets);\n  }\n\n  parsedTypes.forEach(function (parsedType, paramIndex) {\n    var baseType = parsedType.baseType,\n        dimensions = parsedType.dimensions,\n        hasDimensions = parsedType.hasDimensions,\n        hasDynamicDimensions = parsedType.hasDynamicDimensions;\n    var byteLength = values.solidity.types[baseType].byteLength;\n    var dynamicType = values.solidity.types[baseType].dynamic;\n    var valueDecoder = abiTypeDecodes[baseType];\n    var offset = 0;\n    var innerOffsets = [];\n    var paramOp = [];\n\n    if (hasDynamicDimensions === true) {\n      dimensions.forEach(function () {\n        innerOffsets.push(decodeAbiNumber(readBytes(16)));\n      });\n      console.log('inner offsets', innerOffsets);\n    } //\n    // simple single type param\n    //\n\n\n    if (hasDimensions === false) {\n      console.log('simple single type param');\n      op.push(valueDecoder(readBytes(byteLength)));\n      return;\n    } //\n    // simple fixed-length array\n    //\n\n\n    if (hasDimensions === true && hasDynamicDimensions === false) {\n      console.log('simple fixed-length array');\n      var _length = dimensions[0].length;\n\n      for (var i = 0; i < _length; i += 1) {\n        paramOp.push(valueDecoder(readBytes(byteLength)));\n      }\n\n      return op.push(paramOp);\n    } //\n    // shifting to complex mode with offsets\n    //\n    //\n    // we know it's an array now\n    //\n\n\n    var length = dimensions[0].length;\n\n    if (isNumber(length) === true) {\n      console.log('array with length');\n\n      for (var _i = 0; _i < length; _i += 1) {\n        paramOp.push(valueDecoder(readBytes(byteLength)));\n      }\n\n      return op.push(paramOp);\n    }\n\n    console.log('dynamic array');\n    dimensions.forEach(function (dimension, dimensionIndex) {\n      var dynamic = dimension.dynamic,\n          length = dimension.length;\n      var dimensionOp = [];\n\n      if (dynamic === true) {\n        length = decodeAbiNumber(readBytes(16));\n      }\n\n      for (var _i2 = 0; _i2 < length; _i2 += 1) {\n        paramOp.push(valueDecoder(readBytes(byteLength)));\n      } // paramOp.push(dimensionOp)\n\n    });\n    op.push(paramOp);\n  });\n  return op;\n}\n/**\n * Decode a parameter value from it's ABI encoding\n * @method decodeParameter\n * @param {string} type\n * @param {string} val\n * @return {string}\n */\n\n\nfunction decodeParameter(type, val) {\n  return decodeParameters([type], val)[0];\n}\n/**\n * ABI decoded log data\n * @method decodeLog\n * @param {array} inputs\n * @param {string} val\n * @param {array} topics\n * @return {array}\n */\n\n\nfunction decodeLog()\n/*inputs, val, topics*/\n{\n  throw new Error(\"decodeLog not yet implemented\");\n}\n\nmodule.exports = {\n  // for testing and analyzing\n  encodeParametersIntermediate: encodeParametersIntermediate,\n  // web3 implementations\n  encodeFunctionSignature: encodeFunctionSignature,\n  encodeEventSignature: encodeEventSignature,\n  encodeParameter: encodeParameter,\n  encodeParameters: encodeParameters,\n  encodeFunctionCall: encodeFunctionCall,\n  decodeParameter: decodeParameter,\n  decodeParameters: decodeParameters,\n  decodeLog: decodeLog\n};","map":null,"metadata":{},"sourceType":"script"}