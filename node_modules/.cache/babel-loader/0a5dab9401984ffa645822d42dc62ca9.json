{"ast":null,"code":"'use strict';\n/*\n\nOriginal document:\nhttps://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nUpdated document:\nhttps://solidity.readthedocs.io/en/develop/abi-spec.html\n\nAion ABI migration guide:\nhttps://github.com/aionnetwork/aion_fastvm/wiki/Migration-Guide\n\n*/\n\nvar aionLib = require('aion-lib');\n\nvar errors = require('aion-web3-core-helpers').errors;\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar utils = require('./coder-utils');\n\nvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nvar defaultCoerceFunc = function defaultCoerceFunc(type, value) {\n  var match = type.match(paramTypeNumber);\n\n  if (match && parseInt(match[2]) <= 48) {\n    return value.toNumber();\n  }\n\n  return value;\n}; // Shallow copy object (will move to utils/properties in v4)\n\n\nfunction shallowCopy(object) {\n  var result = {};\n\n  for (var key in object) {\n    result[key] = object[key];\n  }\n\n  return result;\n} ///////////////////////////////////\n// Parsing for Solidity Signatures\n\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nvar regexIdentifier = new RegExp(\"^[A-Za-z_][A-Za-z0-9_]*$\");\nvar close = {\n  \"(\": \")\",\n  \"[\": \"]\"\n};\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = 'uint128' + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = 'int128' + type.substring(3);\n  }\n\n  return type;\n}\n\nfunction parseParam(param, allowIndexed) {\n  function throwError(i) {\n    throw errors.UnexpectedParam(param[i], i, param);\n  }\n\n  var parent = {\n    type: '',\n    name: '',\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case '(':\n        if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        delete node.state.allowType;\n        node.type = verifyType(node.type);\n        node.components = [{\n          type: '',\n          name: '',\n          parent: node,\n          state: {\n            allowType: true\n          }\n        }];\n        node = node.components[0];\n        break;\n\n      case ')':\n        delete node.state;\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        delete node.state.allowParams;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case ',':\n        delete node.state;\n        node.type = verifyType(node.type);\n        var sibling = {\n          type: '',\n          name: '',\n          parent: node.parent,\n          state: {\n            allowType: true\n          }\n        };\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case ' ':\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== '') {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== '') {\n            if (allowIndexed && node.name === 'indexed') {\n              node.indexed = true;\n              node.name = '';\n            } else {\n              delete node.state.allowName;\n            }\n          }\n        }\n\n        break;\n\n      case '[':\n        if (!node.state.allowArray) {\n          throwError(i);\n        } //if (!node.array) { node.array = ''; }\n        //node.array += c;\n\n\n        node.type += c;\n        delete node.state.allowArray;\n        delete node.state.allowName;\n        node.state.readArray = true;\n        break;\n\n      case ']':\n        if (!node.state.readArray) {\n          throwError(i);\n        } //node.array += c;\n\n\n        node.type += c;\n        delete node.state.readArray;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          //node.array += c;\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    throw errors.UnexpectedEOF();\n  }\n\n  delete parent.state;\n  parent.type = verifyType(parent.type); //verifyType(parent);\n\n  return parent;\n}\n\nfunction parseSignatureEvent(fragment) {\n  var abi = {\n    anonymous: false,\n    inputs: [],\n    type: 'event'\n  };\n  var match = fragment.match(regexParen);\n\n  if (!match) {\n    throw errors.InvalidEvent(fragment);\n  }\n\n  abi.name = match[1].trim();\n  splitNesting(match[2]).forEach(function (param) {\n    param = parseParam(param, true);\n    param.indexed = !!param.indexed;\n    abi.inputs.push(param);\n  });\n  match[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'anonymous':\n        abi.anonymous = true;\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + mdifier);\n    }\n  });\n\n  if (abi.name && !abi.name.match(regexIdentifier)) {\n    throw errors.InvalidIdentifier(result.name);\n  }\n\n  return abi;\n}\n\nfunction parseSignatureFunction(fragment) {\n  var abi = {\n    constant: false,\n    inputs: [],\n    outputs: [],\n    payable: false,\n    type: 'function'\n  };\n  var comps = fragment.split(' returns ');\n  var left = comps[0].match(regexParen);\n\n  if (!left) {\n    throw errors.InvalidSignature();\n  }\n\n  abi.name = left[1].trim();\n\n  if (!abi.name.match(regexIdentifier)) {\n    throw errors.InvalidIdentifier(left[1]);\n  }\n\n  splitNesting(left[2]).forEach(function (param) {\n    abi.inputs.push(parseParam(param));\n  });\n  left[3].split(' ').forEach(function (modifier) {\n    switch (modifier) {\n      case 'constant':\n        abi.constant = true;\n        break;\n\n      case 'payable':\n        abi.payable = true;\n        break;\n\n      case 'pure':\n        abi.constant = true;\n        abi.stateMutability = 'pure';\n        break;\n\n      case 'view':\n        abi.constant = true;\n        abi.stateMutability = 'view';\n        break;\n\n      case '':\n        break;\n\n      default:\n        console.log('unknown modifier: ' + modifier);\n    }\n  }); // We have outputs\n\n  if (comps.length > 1) {\n    var right = comps[1].match(regexParen);\n\n    if (right[1].trim() != '' || right[3].trim() != '') {\n      throw errors.UnexpectedTokens();\n    }\n\n    splitNesting(right[2]).forEach(function (param) {\n      abi.outputs.push(parseParam(param));\n    });\n  }\n\n  return abi;\n}\n\nfunction parseSignature(fragment) {\n  if (typeof fragment === 'string') {\n    // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n    fragment = fragment.replace(/\\(/g, ' (').replace(/\\)/g, ') ').replace(/\\s+/g, ' ');\n    fragment = fragment.trim();\n\n    if (fragment.substring(0, 6) === 'event ') {\n      return parseSignatureEvent(fragment.substring(6).trim());\n    } else {\n      if (fragment.substring(0, 9) === 'function ') {\n        fragment = fragment.substring(9);\n      }\n\n      return parseSignatureFunction(fragment.trim());\n    }\n  }\n\n  throw errors.UnknownFragment();\n} ///////////////////////////////////\n// Coders\n\n\nvar coderNull = function coderNull(coerceFunc) {\n  return {\n    name: 'null',\n    type: '',\n    encode: function encode(value) {\n      return utils.arrayify([]);\n    },\n    decode: function decode(data, offset) {\n      if (offset > data.length) {\n        throw errors.InvalidCoderValue('null');\n      }\n\n      return {\n        consumed: 0,\n        value: coerceFunc('null', undefined)\n      };\n    },\n    dynamic: false\n  };\n};\n\nvar coderNumber = function coderNumber(coerceFunc, size, signed, localName) {\n  var name = (signed ? 'int' : 'uint') + size * 8;\n  return {\n    localName: localName,\n    name: name,\n    type: name,\n    encode: function encode(value) {\n      try {\n        value = utils.bigNumberify(value);\n      } catch (error) {\n        throw error;\n      }\n\n      value = value.toTwos(size * 8).maskn(size * 8);\n\n      if (signed) {\n        value = value.fromTwos(size * 8).toTwos(128);\n      }\n\n      return utils.padZeros(utils.arrayify(value), 16);\n    },\n    decode: function decode(data, offset) {\n      if (data.length < offset + 16) {\n        throw errors.InsufficientData(name);\n      }\n\n      var junkLength = 16 - size;\n      var sliced = data.slice(offset + junkLength, offset + 16);\n      var value = utils.bigNumberify(sliced);\n\n      if (signed) {\n        value = value.fromTwos(size * 8);\n      } else {\n        value = value.maskn(size * 8);\n      }\n\n      return {\n        consumed: 16,\n        value: coerceFunc(name, value)\n      };\n    }\n  };\n};\n\nvar uint128Coder = coderNumber(function (type, value) {\n  return value;\n}, 16, false);\n\nvar coderBoolean = function coderBoolean(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'bool',\n    type: 'bool',\n    encode: function encode(value) {\n      return uint128Coder.encode(!!value ? 1 : 0);\n    },\n    decode: function decode(data, offset) {\n      try {\n        var result = uint128Coder.decode(data, offset);\n      } catch (error) {\n        throw error;\n      }\n\n      return {\n        consumed: result.consumed,\n        value: coerceFunc('boolean', !result.value.isZero())\n      };\n    }\n  };\n};\n\nvar coderFixedBytes = function coderFixedBytes(coerceFunc, length, localName) {\n  var name = 'bytes' + length;\n  var minLen = length <= 16 ? 16 : 32;\n  return {\n    localName: localName,\n    name: name,\n    type: name,\n    encode: function encode(value) {\n      try {\n        value = utils.arrayify(value); // @TODO: In next major change, the value.length MUST equal the\n        // length, but that is a backward-incompatible change, so here\n        // we just check for things that can cause problems.\n\n        if (value.length > 32) {\n          throw errors.ExcessiveBytes('field bytes');\n        }\n      } catch (error) {\n        throw error;\n      }\n\n      if (value.length === minLen) {\n        return value;\n      }\n\n      var result = Buffer.alloc(minLen);\n      result.set(value);\n      return result;\n    },\n    decode: function decode(data, offset) {\n      if (data.length < offset + minLen) {\n        throw errors.InsufficientData(name);\n      }\n\n      return {\n        consumed: minLen,\n        value: coerceFunc(name, utils.hexlify(data.slice(offset, offset + length)))\n      };\n    }\n  };\n};\n\nvar coderAddress = function coderAddress(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'address',\n    type: 'address',\n    encode: function encode(value) {\n      try {\n        value = utils.arrayify(utils.getAddress(value));\n      } catch (error) {\n        throw errors.InvalidCoderValue('address');\n      }\n\n      var result = Buffer.from(value);\n      return result;\n    },\n    decode: function decode(data, offset) {\n      if (data.length < offset + 32) {\n        throw errors.InsufficientData('address');\n      }\n\n      return {\n        consumed: 32,\n        value: coerceFunc('address', utils.getAddress(utils.hexlify(data.slice(offset, offset + 32))))\n      };\n    }\n  };\n};\n\nfunction _encodeDynamicBytes(value) {\n  var dataLength = parseInt(32 * Math.ceil(value.length / 32));\n  var padding = Buffer.alloc(dataLength - value.length);\n  return utils.concat([uint128Coder.encode(value.length), value, padding]);\n}\n\nfunction _decodeDynamicBytes(data, offset, localName) {\n  if (data.length < offset + 16) {\n    throw errors.InsufficientData('dynamicBytes');\n  }\n\n  var length = uint128Coder.decode(data, offset).value;\n  offset += 16;\n\n  try {\n    length = length.toNumber();\n  } catch (error) {\n    throw errors.ExcessiveBytes('dynamicBytes');\n  }\n\n  if (data.length < offset + length) {\n    throw errors.InsufficientData('dynamicBytes');\n  }\n\n  return {\n    consumed: parseInt(32 * Math.ceil(length / 32)),\n    value: data.slice(offset, offset + length)\n  };\n}\n\nvar coderDynamicBytes = function coderDynamicBytes(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'bytes',\n    type: 'bytes',\n    encode: function encode(value) {\n      try {\n        value = utils.arrayify(value);\n      } catch (error) {\n        throw errors.InvalidCoderValue('bytes');\n      }\n\n      return _encodeDynamicBytes(value);\n    },\n    decode: function decode(data, offset) {\n      var result = _decodeDynamicBytes(data, offset, localName);\n\n      result.value = coerceFunc('bytes', utils.hexlify(result.value));\n      return result;\n    },\n    dynamic: true\n  };\n};\n\nvar coderString = function coderString(coerceFunc, localName) {\n  return {\n    localName: localName,\n    name: 'string',\n    type: 'string',\n    encode: function encode(value) {\n      if (typeof value !== 'string') {\n        throw errors.InvalidCoderValue('string');\n      }\n\n      return _encodeDynamicBytes(utils.toUtf8Bytes(value));\n    },\n    decode: function decode(data, offset) {\n      var result = _decodeDynamicBytes(data, offset, localName);\n\n      result.value = coerceFunc('string', utils.toUtf8String(result.value));\n      return result;\n    },\n    dynamic: true\n  };\n};\n\nfunction alignSize(size) {\n  return parseInt(16 * Math.ceil(size / 16));\n}\n\nfunction pack(coders, values) {\n  if (Array.isArray(values)) {// do nothing\n  } else if (values && typeof values === 'object') {\n    var arrayValues = [];\n    coders.forEach(function (coder) {\n      arrayValues.push(values[coder.localName]);\n    });\n    values = arrayValues;\n  } else {\n    throw new Error('invalid tuple value');\n    throw errors.InvalidCoderValue('tuple');\n  }\n\n  if (coders.length !== values.length) {\n    throw errors.LengthMismatch('Types/Value');\n  }\n\n  var parts = [];\n  coders.forEach(function (coder, index) {\n    parts.push({\n      dynamic: coder.dynamic,\n      value: coder.encode(values[index])\n    });\n  });\n  var staticSize = 0,\n      dynamicSize = 0;\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      staticSize += 16;\n      dynamicSize += alignSize(part.value.length);\n    } else {\n      staticSize += alignSize(part.value.length);\n    }\n  });\n  var offset = 0,\n      dynamicOffset = staticSize;\n  var data = Buffer.alloc(staticSize + dynamicSize);\n  parts.forEach(function (part, index) {\n    if (part.dynamic) {\n      //uint128Coder.encode(dynamicOffset).copy(data, offset);\n      data.set(uint128Coder.encode(dynamicOffset), offset);\n      offset += 16; //part.value.copy(data, dynamicOffset);  @TODO\n\n      data.set(part.value, dynamicOffset);\n      dynamicOffset += alignSize(part.value.length);\n    } else {\n      //part.value.copy(data, offset);  @TODO\n      data.set(part.value, offset);\n      offset += alignSize(part.value.length);\n    }\n  });\n  return data;\n}\n\nfunction unpack(coders, data, offset) {\n  var baseOffset = offset;\n  var consumed = 0;\n  var value = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      var dynamicOffset = uint128Coder.decode(data, offset);\n      var result = coder.decode(data, baseOffset + dynamicOffset.value.toNumber()); // The dynamic part is leap-frogged somewhere else; doesn't count towards size\n\n      result.consumed = dynamicOffset.consumed;\n    } else {\n      var result = coder.decode(data, offset);\n    }\n\n    if (result.value != undefined) {\n      value.push(result.value);\n    }\n\n    offset += result.consumed;\n    consumed += result.consumed;\n  });\n  coders.forEach(function (coder, index) {\n    var name = coder.localName;\n\n    if (!name) {\n      return;\n    }\n\n    if (typeof name === 'object') {\n      name = name.name;\n    }\n\n    if (!name) {\n      return;\n    }\n\n    if (name === 'length') {\n      name = '_length';\n    }\n\n    if (value[name] != null) {\n      return;\n    }\n\n    value[name] = value[index];\n  });\n  return {\n    value: value,\n    consumed: consumed\n  };\n  return result;\n}\n\nfunction coderArray(coerceFunc, coder, length, localName) {\n  var type = coder.type + '[' + (length >= 0 ? length : '') + ']';\n  return {\n    coder: coder,\n    localName: localName,\n    length: length,\n    name: 'array',\n    type: type,\n    encode: function encode(value) {\n      if (!Array.isArray(value)) {\n        throw errors.InvalidCoderValue('array');\n      }\n\n      var count = length;\n      var result = Buffer.alloc(0); // buffer null\n\n      if (count === -1) {\n        count = value.length;\n        result = uint128Coder.encode(count);\n      }\n\n      if (count !== value.length) {\n        throw errors.LengthMismatch('Array value');\n      }\n\n      var coders = [];\n      value.forEach(function (value) {\n        coders.push(coder);\n      });\n      return utils.concat([result, pack(coders, value)]);\n    },\n    decode: function decode(data, offset) {\n      // @TODO:\n      //if (data.length < offset + length * 32) { throw new Error('invalid array'); }\n      var consumed = 0;\n      var count = length;\n\n      if (count === -1) {\n        try {\n          var decodedLength = uint128Coder.decode(data, offset);\n        } catch (error) {\n          throw errors.InsufficientData('dynamic array');\n        }\n\n        try {\n          count = decodedLength.value.toNumber();\n        } catch (error) {\n          throw errors.ExcessiveBytes('Array');\n        }\n\n        consumed += decodedLength.consumed;\n        offset += decodedLength.consumed;\n      } // We don't want the children to have a localName\n\n\n      var subCoder = {\n        name: coder.name,\n        type: coder.type,\n        encode: coder.encode,\n        decode: coder.decode,\n        dynamic: coder.dynamic\n      };\n      var coders = [];\n\n      for (var i = 0; i < count; i++) {\n        coders.push(subCoder);\n      }\n\n      var result = unpack(coders, data, offset);\n      result.consumed += consumed;\n      result.value = coerceFunc(type, result.value);\n      return result;\n    },\n    dynamic: length === -1 || coder.dynamic\n  };\n}\n\nfunction coderTuple(coerceFunc, coders, localName) {\n  var dynamic = false;\n  var types = [];\n  coders.forEach(function (coder) {\n    if (coder.dynamic) {\n      dynamic = true;\n    }\n\n    types.push(coder.type);\n  });\n  var type = 'tuple(' + types.join(',') + ')';\n  return {\n    coders: coders,\n    localName: localName,\n    name: 'tuple',\n    type: type,\n    encode: function encode(value) {\n      return pack(coders, value);\n    },\n    decode: function decode(data, offset) {\n      var result = unpack(coders, data, offset);\n      result.value = coerceFunc(type, result.value);\n      return result;\n    },\n    dynamic: dynamic\n  };\n}\n/*\nfunction getTypes(coders) {\n    var type = coderTuple(coders).type;\n    return type.substring(6, type.length - 1);\n}\n*/\n\n\nfunction splitNesting(value) {\n  var result = [];\n  var accum = '';\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === ',' && depth === 0) {\n      result.push(accum);\n      accum = '';\n    } else {\n      accum += c;\n\n      if (c === '(') {\n        depth++;\n      } else if (c === ')') {\n        depth--;\n\n        if (depth === -1) {\n          throw errors.UnbalanceParenthesis();\n        }\n      }\n    }\n  }\n\n  result.push(accum);\n  return result;\n}\n\nvar paramTypeSimple = {\n  address: coderAddress,\n  bool: coderBoolean,\n  string: coderString,\n  bytes: coderDynamicBytes\n};\n\nfunction getTupleParamCoder(coerceFunc, components, localName) {\n  if (!components) {\n    components = [];\n  }\n\n  var coders = [];\n  components.forEach(function (component) {\n    coders.push(getParamCoder(coerceFunc, component));\n  });\n  return coderTuple(coerceFunc, coders, localName);\n}\n\nfunction getParamCoder(coerceFunc, param) {\n  var coder = paramTypeSimple[param.type];\n\n  if (coder) {\n    return coder(coerceFunc, param.name);\n  }\n\n  var match = param.type.match(paramTypeNumber);\n\n  if (match) {\n    var size = parseInt(match[2] || 128);\n\n    if (size === 0 || size > 128 || size % 8 !== 0) {\n      throw errors.InvalidBitLength(match[1]);\n    }\n\n    return coderNumber(coerceFunc, size / 8, match[1] === 'int', param.name);\n  }\n\n  var match = param.type.match(paramTypeBytes);\n\n  if (match) {\n    var size = parseInt(match[1]);\n\n    if (size === 0 || size > 32) {\n      throw errors.InvalidBytesLength();\n    }\n\n    return coderFixedBytes(coerceFunc, size, param.name);\n  }\n\n  var match = param.type.match(paramTypeArray);\n\n  if (match) {\n    param = shallowCopy(param);\n    var size = parseInt(match[2] || -1);\n    param.type = match[1];\n    return coderArray(coerceFunc, getParamCoder(coerceFunc, param), size, param.name);\n  }\n\n  if (param.type.substring(0, 5) === 'tuple') {\n    return getTupleParamCoder(coerceFunc, param.components, param.name);\n  }\n\n  if (type === '') {\n    return coderNull(coerceFunc);\n  }\n\n  throw errors.InvalidType();\n}\n\nfunction Coder(coerceFunc) {\n  if (!(this instanceof Coder)) {\n    throw new Error('missing new');\n  }\n\n  if (!coerceFunc) {\n    coerceFunc = defaultCoerceFunc;\n  }\n\n  utils.defineProperty(this, 'coerceFunc', coerceFunc);\n} // Legacy name support\n// @TODO: In the next major version, remove names from decode/encode and don't do this\n\n\nfunction populateNames(type, name) {\n  if (!name) {\n    return;\n  }\n\n  if (type.type.substring(0, 5) === 'tuple' && typeof name !== 'string') {\n    if (type.components.length != name.names.length) {\n      throw errors.LengthMismatch('Names/Types');\n    }\n\n    name.names.forEach(function (name, index) {\n      populateNames(type.components[index], name);\n    });\n    name = name.name || '';\n  }\n\n  if (!type.name && typeof name === 'string') {\n    type.name = name;\n  }\n}\n\nutils.defineProperty(Coder.prototype, 'encode', function (names, types, values) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    values = types;\n    types = names;\n    names = [];\n  }\n\n  if (types.length !== values.length) {\n    throw errors.LengthMismatch('Types/Values');\n  }\n\n  var coders = [];\n  types.forEach(function (type, index) {\n    // Convert types to type objects\n    //   - \"uint foo\" => { type: \"uint\", name: \"foo\" }\n    //   - \"tuple(uint, uint)\" => { type: \"tuple\", components: [ { type: \"uint\" }, { type: \"uint\" }, ] }\n    if (typeof type === 'string') {\n      type = parseParam(type);\n    } // Legacy support for passing in names (this is going away in the next major version)\n\n\n    populateNames(type, names[index]);\n    var coder = getParamCoder(this.coerceFunc, type);\n    coders.push(coder);\n  }, this);\n  var preOp = coderTuple(this.coerceFunc, coders).encode(values);\n  var op = utils.hexlify(preOp);\n  return op;\n});\nutils.defineProperty(Coder.prototype, 'decode', function (names, types, data) {\n  // Names is optional, so shift over all the parameters if not provided\n  if (arguments.length < 3) {\n    data = types;\n    types = names;\n    names = [];\n  }\n\n  data = utils.arrayify(data);\n  var coders = [];\n  types.forEach(function (type, index) {\n    // See encode for details\n    if (typeof type === 'string') {\n      type = parseParam(type);\n    } // Legacy; going away in the next major version\n\n\n    populateNames(type, names[index]);\n    coders.push(getParamCoder(this.coerceFunc, type));\n  }, this);\n  return coderTuple(this.coerceFunc, coders).decode(data, 0).value;\n});\nutils.defineProperty(Coder, 'defaultCoder', new Coder());\nutils.defineProperty(Coder, 'parseSignature', parseSignature);\nmodule.exports = Coder;","map":null,"metadata":{},"sourceType":"script"}