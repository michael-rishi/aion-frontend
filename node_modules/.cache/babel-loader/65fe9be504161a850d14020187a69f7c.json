{"ast":null,"code":"/*\n * Copyright (c) 2017-2018 Aion foundation.\n *\n *     This file is part of the aion network project.\n *\n *     The aion network project is free software: you can redistribute it \n *     and/or modify it under the terms of the GNU General Public License \n *     as published by the Free Software Foundation, either version 3 of \n *     the License, or any later version.\n *\n *     The aion network project is distributed in the hope that it will \n *     be useful, but WITHOUT ANY WARRANTY; without even the implied \n *     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \n *     See the GNU General Public License for more details.\n *\n *     You should have received a copy of the GNU General Public License\n *     along with the aion network project source files.  \n *     If not, see <https://www.gnu.org/licenses/>.\n *\n * Contributors:\n *     Aion foundation.\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jennifer/Script/helloAVM_web3_aiwa/node_modules/@babel/runtime/helpers/createClass\");\n\nvar utils = require('./coder-utils');\n\nvar codec = require('./coder');\n\nvar ABICoder =\n/*#__PURE__*/\nfunction () {\n  function ABICoder() {\n    _classCallCheck(this, ABICoder);\n\n    if (!this) {\n      return new Error('missing \"new\" keyword');\n    }\n  } // Gets the right Coder based on the Param passed\n\n\n  _createClass(ABICoder, [{\n    key: \"getCoder\",\n    value: function getCoder(param) {\n      var comps = param.trim().split(\" \").map(function (comp) {\n        return comp.trim();\n      });\n      param = comps[0];\n      var localName = comps[1] || null; // Checks for a 2D Array and if so, builds the inner-most coder \n      // for the arrays on the inside\n\n      if (param.substring(param.length - 4) === \"[][]\") {\n        var coder = param.substring(0, param.length - 2);\n\n        if (!coder.includes(\"string\") && !coder.includes(\"address\")) {\n          return new codec.ArrayCoder(this.getCoder(coder), localName);\n        }\n      } // Switch statement to find all the different types of coders\n\n\n      switch (param.toLowerCase()) {\n        case \"byte\":\n          return new codec.ByteCoder(\"byte\", 1, 0x01, localName);\n\n        case \"boolean\":\n          return new codec.BooleanCoder(\"boolean\", 0x02, localName);\n\n        case \"char\":\n          return new codec.CharCoder(\"char\", 0x03, localName);\n\n        case \"short\":\n          return new codec.ByteCoder(\"short\", 2, 0x04, localName);\n\n        case \"int\":\n          return new codec.ByteCoder(\"int\", 4, 0x05, localName);\n\n        case \"long\":\n          return new codec.ByteCoder(\"long\", 8, 0x06, localName);\n\n        case \"float\":\n          return new codec.FloatCoder(\"float\", 4, 0x07, localName);\n\n        case \"double\":\n          return new codec.FloatCoder(\"double\", 8, 0x08, localName);\n\n        case \"string\":\n          return new codec.StringCoder(localName);\n\n        case \"address\":\n          return new codec.AddressCoder(localName);\n\n        case \"byte[]\":\n          return new codec.ByteArrayCoder(\"byte[]\", 1, 0x11, localName);\n\n        case \"boolean[]\":\n          return new codec.BooleanArrayCoder(\"boolean[]\", 0x12, localName);\n\n        case \"char[]\":\n          return new codec.CharArrayCoder(\"char[]\", 0x13, localName);\n\n        case \"short[]\":\n          return new codec.ByteArrayCoder(\"short[]\", 2, 0x14, localName);\n\n        case \"int[]\":\n          return new codec.ByteArrayCoder(\"int[]\", 4, 0x15, localName);\n\n        case \"long[]\":\n          return new codec.ByteArrayCoder(\"long[]\", 8, 0x16, localName);\n\n        case \"float[]\":\n          return new codec.FloatArrayCoder(\"float[]\", 4, 0x17, localName);\n\n        case \"double[]\":\n          return new codec.FloatArrayCoder(\"double[]\", 8, 0x18, localName);\n\n        case \"string[]\":\n          return new codec.ArrayCoder(new codec.StringCoder(\"string\"), localName);\n\n        case \"address[]\":\n          return new codec.ArrayCoder(new codec.AddressCoder(\"address\"), localName);\n      }\n\n      throw new Error(\"unknown - \" + param);\n    } // Creates a new Instance of a Reader\n\n  }, {\n    key: \"getReader\",\n    value: function getReader(data) {\n      return new codec.Reader(data);\n    } // Creates a new Instance of a Writer\n\n  }, {\n    key: \"getWriter\",\n    value: function getWriter() {\n      return new codec.Writer();\n    }\n  }, {\n    key: \"readyDeploy\",\n    value: function readyDeploy(jarPath, encodedArgs) {\n      // Converts the jarfile into Bytes\n      var jarArrayBuffer = new Uint8Array(jarPath); // Get the byte length of the Jar and the encoded data arguments\n\n      var codeLength = jarArrayBuffer.byteLength;\n      var argsLength = encodedArgs.length; // Create a stream which will handle the big endian encoding of the jar file\n\n      var combinedBinary = new Uint8Array(4 + codeLength + 4 + argsLength);\n      var combinedStream = new utils.endianEncoding(combinedBinary);\n      combinedStream.writeFour(codeLength);\n      combinedStream.writeBytes(jarArrayBuffer, codeLength);\n      combinedStream.writeFour(argsLength);\n      combinedStream.writeBytes(encodedArgs, argsLength);\n      return utils.hexlify(combinedBinary);\n    } // Encodes Data Types and their Values which are to be used in a Method\n\n  }, {\n    key: \"encode\",\n    value: function encode(types, values) {\n      var _this = this;\n\n      if (types.length !== values.length) {\n        return new Error(\"types/values length mismatch\");\n      }\n\n      var coders = types.map(function (type) {\n        return _this.getCoder(type);\n      });\n      var writer = this.getWriter();\n      coders.forEach(function (coder, index) {\n        var array = null;\n\n        if (coder.type.substring(coder.type.length - 2) === \"[]\") {\n          array = true;\n        }\n\n        coder.encode(writer, values[index], array);\n      });\n      return writer._data;\n    } // Encodes Specifically for a Method Call\n\n  }, {\n    key: \"encodeMethod\",\n    value: function encodeMethod(method, types, values) {\n      var sigWriter = this.getWriter();\n      var methodCoder = this.getCoder(\"string\");\n      methodCoder.encode(sigWriter, method, null);\n      return utils.hexlify(utils.concat([sigWriter._data, this.encode(types, values)]));\n    } // Decodes the AVM Contract Data based on the Data itself and the Type of Data expected\n\n  }, {\n    key: \"decode\",\n    value: function decode(type, data) {\n      var reader = this.getReader(utils.arrayify(data));\n      var coder = this.getCoder(type);\n      var array = null;\n      if (type.substring(type.length - 2) === \"[]\") array = true;\n      return coder.decode(reader, array);\n    }\n  }]);\n\n  return ABICoder;\n}();\n\nmodule.exports = ABICoder;","map":null,"metadata":{},"sourceType":"script"}