{"ast":null,"code":"var _require = require('underscore'),\n    isString = _require.isString,\n    isArray = _require.isArray;\n\nvar patterns = require('./patterns');\n\nvar values = require('./values');\n\nvar _require2 = require('./crypto'),\n    blake2b256 = _require2.blake2b256,\n    nacl = _require2.nacl;\n\nvar _require3 = require('./formats'),\n    prependZeroX = _require3.prependZeroX,\n    removeLeadingZeroX = _require3.removeLeadingZeroX,\n    randomHexBuffer = _require3.randomHexBuffer,\n    bufferToZeroXHex = _require3.bufferToZeroXHex,\n    toBuffer = _require3.toBuffer;\n\nvar validNonA0PrefixAddresses = [\"0000000000000000000000000000000000000000000000000000000000000200\", \"08efa07244bacb5dc92daef46474560b57e9cfc2be62072fa21decf64051a317\", \"0a0b61014dc764640ee6087095faf68dfeb4e4b9ee681225611fea65932c93e4\", \"1318abaea6686c79eaa4ba37f5eef843bd065e74560ed1094133641b4f2395b8\", \"24a970ec53022623d95989e3340ff180a843c8645841699c4c19a227287901cf\", \"38dd1ae75523611bed9d4b647016dc8b0735c42317bd03e9bd65ceca69e8c46c\", \"64b09d162e2f91d3308381f28c02b9d0e5cb4270a43465b696e1db6210aad189\", \"7b8289c4b1ada70af8794b508f6db000ca25f1d1821c053da302a0403f73b29e\", \"aebf26d4d5438304e277a3d5104a3b056d8617f586f33560d4b2e7984a2bfe01\", \"af504da64d6cb7ec06a462b2c43a3cb4e482db3b41fde42b537f4c64fedc894b\", \"af694e98b964b275d723c2c66e224739d97d36125bba985215bca1075656b82e\", \"c00dcc9fe51c73767fad07cd4da990a8aa7487f40ba5718f711b4fdc09ae5b6e\", \"cb68ed818e6f712b315d53e0cce541b2d2e4c0d101ef1fcc91bccef1c21dffd7\", \"d801109bab93a4ab71c16e85389d9c366a23a975693cbdcc7e6db85561f1d5ce\", \"f5079727f0c503b5eae232dbd303128338576fc1db867892ae07dcc920691ab9\"]; // address + message signature length\n\nvar aionPubSigLen = nacl.sign.publicKeyLength + nacl.sign.signatureLength;\n\nfunction createKeyPair(_ref) {\n  var entropy = _ref.entropy,\n      privateKey = _ref.privateKey;\n  var kp;\n  var keyPair;\n  var ent;\n  var priv;\n\n  if (privateKey !== undefined) {\n    priv = toBuffer(privateKey);\n    kp = nacl.sign.keyPair.fromSecretKey(priv);\n    keyPair = {\n      _privateKey: priv,\n      privateKey: bufferToZeroXHex(priv),\n      publicKey: toBuffer(kp.publicKey)\n    };\n    return keyPair;\n  }\n\n  if (entropy === undefined) {\n    ent = randomHexBuffer();\n  }\n\n  if (typeof entropy === 'string') {\n    ent = toBuffer(entropy);\n  } // entropy sandwich\n\n\n  ent = Buffer.concat([blake2b256(randomHexBuffer()), // bread\n  blake2b256(ent), // peanut butter\n  blake2b256(randomHexBuffer()) // bread ðŸ˜‰\n  ]);\n  kp = nacl.sign.keyPair.fromSeed(ent.slice(0, nacl.sign.seedLength));\n  priv = toBuffer(kp.secretKey);\n  keyPair = {\n    _privateKey: priv,\n    privateKey: bufferToZeroXHex(priv),\n    publicKey: toBuffer(kp.publicKey)\n  };\n  return keyPair;\n}\n\nvar isPrivateKey = function isPrivateKey(val) {\n  return (isArray(val) === true || Buffer.isBuffer(val) === true) && val.length > 0;\n};\n\nfunction createA0Address(publicKey) {\n  var pkHash = Buffer.from(blake2b256(publicKey)).slice(1, 32);\n  var address = Buffer.concat([values.addresses.identifier, pkHash], 32);\n  return prependZeroX(address.toString('hex'));\n}\n\nfunction isAccountAddress(val) {\n  if (val === undefined || isString(val) === false) {\n    return false;\n  }\n\n  return patterns.address.test(val) === true || patterns.hash.test(val) && validNonA0PrefixAddresses.indexOf(val.replace(/^0x/, \"\")) > 0;\n}\n\nfunction bit(arr, index) {\n  var byteOffset = Math.floor(index / 8);\n  var bitOffset = index % 8;\n  var uint8 = arr[byteOffset];\n  return uint8 >> bitOffset & 0x1;\n}\n\nfunction createChecksumAddress(val) {\n  var address = removeLeadingZeroX(val.toLowerCase());\n  var addressHash = blake2b256(toBuffer(address));\n  return prependZeroX(address.split('').map(function (item, index) {\n    var char = address[index];\n\n    if (isNaN(char) === false) {\n      // numeric\n      return char;\n    }\n\n    return bit(addressHash, index) === 1 ? char.toUpperCase() : char.toLowerCase();\n  }).join(''));\n}\n\nvar isValidChecksumAddress = function isValidChecksumAddress(val) {\n  return val === createChecksumAddress(val);\n};\n\nfunction equalAddresses(addr1, addr2) {\n  return removeLeadingZeroX(addr1.toLowerCase()) === removeLeadingZeroX(addr2.toLowerCase());\n}\n\nmodule.exports = {\n  createKeyPair: createKeyPair,\n  isPrivateKey: isPrivateKey,\n  createA0Address: createA0Address,\n  isAccountAddress: isAccountAddress,\n  createChecksumAddress: createChecksumAddress,\n  isValidChecksumAddress: isValidChecksumAddress,\n  equalAddresses: equalAddresses,\n  aionPubSigLen: aionPubSigLen\n};","map":null,"metadata":{},"sourceType":"script"}