{"ast":null,"code":"var _require = require('underscore'),\n    isString = _require.isString,\n    isArray = _require.isArray;\n\nvar patterns = require('./patterns');\n\nvar values = require('./values');\n\nvar _require2 = require('./crypto'),\n    blake2b256 = _require2.blake2b256,\n    nacl = _require2.nacl;\n\nvar _require3 = require('./formats'),\n    prependZeroX = _require3.prependZeroX,\n    removeLeadingZeroX = _require3.removeLeadingZeroX,\n    randomHexBuffer = _require3.randomHexBuffer,\n    bufferToZeroXHex = _require3.bufferToZeroXHex,\n    toBuffer = _require3.toBuffer; // address + message signature length\n\n\nvar aionPubSigLen = nacl.sign.publicKeyLength + nacl.sign.signatureLength;\n\nfunction createKeyPair(_ref) {\n  var entropy = _ref.entropy,\n      privateKey = _ref.privateKey;\n  var kp;\n  var keyPair;\n  var ent;\n  var priv;\n\n  if (privateKey !== undefined) {\n    priv = toBuffer(privateKey);\n    kp = nacl.sign.keyPair.fromSecretKey(priv);\n    keyPair = {\n      _privateKey: priv,\n      privateKey: bufferToZeroXHex(priv),\n      publicKey: toBuffer(kp.publicKey)\n    };\n    return keyPair;\n  }\n\n  if (entropy === undefined) {\n    ent = randomHexBuffer();\n  }\n\n  if (typeof entropy === 'string') {\n    ent = toBuffer(entropy);\n  } // entropy sandwich\n\n\n  ent = Buffer.concat([blake2b256(randomHexBuffer()), // bread\n  blake2b256(ent), // peanut butter\n  blake2b256(randomHexBuffer()) // bread ðŸ˜‰\n  ]);\n  kp = nacl.sign.keyPair.fromSeed(ent.slice(0, nacl.sign.seedLength));\n  priv = toBuffer(kp.secretKey);\n  keyPair = {\n    _privateKey: priv,\n    privateKey: bufferToZeroXHex(priv),\n    publicKey: toBuffer(kp.publicKey)\n  };\n  return keyPair;\n}\n\nvar isPrivateKey = function isPrivateKey(val) {\n  return (isArray(val) === true || Buffer.isBuffer(val) === true) && val.length > 0;\n};\n\nfunction createA0Address(publicKey) {\n  var pkHash = Buffer.from(blake2b256(publicKey)).slice(1, 32);\n  var address = Buffer.concat([values.addresses.identifier, pkHash], 32);\n  return prependZeroX(address.toString('hex'));\n}\n\nfunction isAccountAddress(val) {\n  if (val === undefined || isString(val) === false) {\n    return false;\n  }\n\n  return patterns.address.test(val) === true;\n}\n\nfunction bit(arr, index) {\n  var byteOffset = Math.floor(index / 8);\n  var bitOffset = index % 8;\n  var uint8 = arr[byteOffset];\n  return uint8 >> bitOffset & 0x1;\n}\n\nfunction createChecksumAddress(val) {\n  var address = removeLeadingZeroX(val.toLowerCase());\n  var addressHash = blake2b256(toBuffer(address));\n  return prependZeroX(address.split('').map(function (item, index) {\n    var char = address[index];\n\n    if (isNaN(char) === false) {\n      // numeric\n      return char;\n    }\n\n    return bit(addressHash, index) === 1 ? char.toUpperCase() : char.toLowerCase();\n  }).join(''));\n}\n\nvar isValidChecksumAddress = function isValidChecksumAddress(val) {\n  return val === createChecksumAddress(val);\n};\n\nfunction equalAddresses(addr1, addr2) {\n  return removeLeadingZeroX(addr1.toLowerCase()) === removeLeadingZeroX(addr2.toLowerCase());\n}\n\nmodule.exports = {\n  createKeyPair: createKeyPair,\n  isPrivateKey: isPrivateKey,\n  createA0Address: createA0Address,\n  isAccountAddress: isAccountAddress,\n  createChecksumAddress: createChecksumAddress,\n  isValidChecksumAddress: isValidChecksumAddress,\n  equalAddresses: equalAddresses,\n  aionPubSigLen: aionPubSigLen\n};","map":null,"metadata":{},"sourceType":"script"}